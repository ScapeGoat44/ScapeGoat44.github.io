<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ScapeGoat44</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-11-21T03:50:01.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/11/11/MD5%E7%AE%97%E6%B3%95%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/11/11/MD5算法攻击方式总结/</id>
    <published>2018-11-11T12:44:55.000Z</published>
    <updated>2018-11-21T03:50:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MD5算法攻击方式总结"><a href="#MD5算法攻击方式总结" class="headerlink" title="MD5算法攻击方式总结"></a>MD5算法攻击方式总结</h1><h2 id="0x01前言"><a href="#0x01前言" class="headerlink" title="0x01前言"></a>0x01前言</h2><p>MD5算法攻击在CTF中算是比较经常遇到的，其攻击方式大同小异，主要包括：MD5绕过、MD5爆破、MD5长度扩展攻击等。为加深印象特写此笔记以作记录。</p><h2 id="0x02MD5绕过"><a href="#0x02MD5绕过" class="headerlink" title="0x02MD5绕过"></a>0x02MD5绕过</h2><p>关于MD5绕过主要分为以下三种攻击方式<br>第一种</p><pre><code>if($_POST[&#39;param1&#39;]!=$_POST[&#39;param2&#39;] &amp;&amp; md5($_POST[&#39;param1&#39;])==md5($_POST[&#39;param2&#39;])){        die(&quot;success!&quot;);}</code></pre><p>对于这种最简单的绕过，可以使用两个字符串绕过，也可以使用数组绕过</p><pre><code>param1=240610708&amp;param2=QNKCDZOparam1[]=1&amp;param2[]=2</code></pre><p>第二种</p><pre><code>if($_POST[&#39;param1&#39;]!==$_POST[&#39;param2&#39;] &amp;&amp; md5($_POST[&#39;param1&#39;])===md5($_POST[&#39;param2&#39;])){        die(&quot;success!&quot;);    }</code></pre><p>这里使用的 ===（强等于），所以直接使用数组绕过就行</p><pre><code>param1[]=1&amp;param2[]=2</code></pre><p>第三种</p><pre><code>if((string)$_POST[&#39;param1&#39;]!==(string)$_POST[&#39;param2&#39;] &amp;&amp; md5($_POST[&#39;param1&#39;])===md5($_POST[&#39;param2&#39;])){        die(&quot;success!);    }</code></pre><p>使用了强制字符串转化，在这里直接使用现成的payload就可以</p><pre><code>param1=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2param2=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2</code></pre><p>在这里还可以使用下面两张MD5相同的图片作为参数提交<br><img src="https://ws1.sinaimg.cn/large/006Zfwodly1fx484rzf4jj30zk0rd7d3.jpg" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/006Zfwodly1fx485nv13nj30zk0p57d3.jpg" alt=""></p><p>我们使用python（python2）将文件读取出来并进行url编码，post提交即可</p><pre><code>import urllibresult = urllib.quote(open(&quot;md5_1.jpg&quot;,&quot;rb&quot;).read())print result</code></pre><p>payload太长所以就不贴了。。</p><h2 id="0x03MD5爆破"><a href="#0x03MD5爆破" class="headerlink" title="0x03MD5爆破"></a>0x03MD5爆破</h2><p>关于MD5爆破一定要记得MD5的组成一定是0-9和a-f组成的，只要记住这一点，爆破就很简单了。。<br>例一：</p><pre><code>手贱：某天A君的网站被日，管理员密码被改，死活登不上，去数据库一看，啥，这密码md5不是和原来一样吗？为啥登不上咧？d78b6f302l25cdc811adfe8d4e7c9fd34请提交PCTF{原来的管理员密码}</code></pre><p>通过对题目提供的MD5的分析 , 发现MD5的长度为 : 33 , 而我们知道MD5是不可能有33位的 , 最接近的就是32位 , 说明这个MD5已经被黑客修改过了 , 因此利用Python脚本一个一个去掉其中的某一个字符 , 然后再逐个查询MD5的值 , 最终得到原来的密码（ps：不知道这题是该叫手残还是眼瞎 ）<br>这道题目其实严格算上去不算是爆破，想要爆破也可以：</p><pre><code>mymd5 = &quot;d78b6f302l25cdc811adfe8d4e7c9fd34&quot;for i in xrange(33):       newmd5 = mymd5[:i]+mymd5[i+1:]    print newmd5</code></pre><p> 例二：</p><pre><code> ROT-13变身了QUESTION: 提示：1、回旋13，回不回？ 2、有81,450,625种可能性格式：flag{}破解下面的密文：83 89 78 84 45 86 96 45 115 121 110 116 136 132 132 132 108 128 117 118 134 110 123 111 110 127 108 112     124 122 108 118 128 108 131 114 127 134 108 116 124 124 113 108 76 76 76 76 138 23 90 81 66 71 64 69     114 65 112 64 66 63 69 61 70 114 62 66 61 62 69 67 70 63 61 110 110 112 64 68 62 70 61 112 111 112</code></pre><p>ROT13：只对字母进行编码，用当前字母往前数的第13个字母替换当前字母，例如当前为A，编码后变成N，当前为B，编码后变成O，以此类推顺序循环。所以可以使用python脚本得到answer：</p><pre><code>lst=[83,89,78,84,45,86,96,45,115,121,110,116,136,132,132,132,108,128,117,118,134,110,123,111,110,127,108,112,124,122,108,118,128,108,131,114,127,134,108,116,124,124,113,108,76,76,76,76,138,23,90,81,66,71,64,69,114,65,112,64,66,63,69,61,70,114,62,66,61,62,69,67,70,63,61,110,110,112,64,68,62,70,61,112,111,112]lst=[chr(i-13) for i in lst]print &quot;&quot;.join(lst)</code></pre><p>这样我们就可以得到：<br>FLAG IS flag{www_shiyanbar_com_is_verygood????}<br>MD5:38e4c352809e150186920aac37190cbc<br>因为后面是问号，所以用python写个简单的脚本爆破一下就ok</p><pre><code>import hashlibdef test():    count=0    md5=&#39;38e4c352809e150186920aac37190cbc&#39;    str=&#39;flag{www_shiyanbar_com_is_very_good_&#39;    while count==0:        for i in range(32,127):            a=chr(i)            for i in range(32,127):                b=chr(i)                for i in range(32,127):                    c=chr(i)                    for i in range(32,127):                        d=chr(i)                        test=str+a+b+c+d+&#39;}&#39;                        m=hashlib.md5()                        m.update(test)                        m=m.hexdigest()                        if(cmp(m,md5)==0):                             count=1                             print &#39;ok&#39;                             print testif __name__ == &#39;__main__&#39;:    test()    pass</code></pre><p>得到flag{www_shiyanbar_com_is_verygood@8Mu}</p><h2 id="0x04MD5长度扩展攻击"><a href="#0x04MD5长度扩展攻击" class="headerlink" title="0x04MD5长度扩展攻击"></a>0x04MD5长度扩展攻击</h2><p>哈希长度扩展攻击(hash lengthextensionattacks)是指针对某些允许包含额外信息的加密散列函数的攻击手段。次攻击适用于MD5和SHA-1等基于Merkle–Damgård构造的算法。<br>如果需要明白MD5算法长度扩展攻击，那么就必须了解MD5算法的实现原理</p><h3 id="理解哈希算法流程"><a href="#理解哈希算法流程" class="headerlink" title="理解哈希算法流程"></a>理解哈希算法流程</h3><p>易受哈希长度扩展攻击的哈希算法：SHA系列和MD系列。这两个系列的哈希算法都有一个共同点——基于Merkle–Damgård构造。</p><p><img src="https://ws1.sinaimg.cn/large/006Zfwodly1fx4ciui0a4j30or0brq55.jpg" alt=""></p><p>上图可以看出，Merkle–Damgård算法的流程如下：</p><ol><li>把消息划分为n个消息块</li><li>对最后一个消息块做长度填充</li><li>每个消息块都会和一个输入向量做一个运算，把这个计算结果当成下个消息块的输入向量</li></ol><h3 id="理解MD5算法流程"><a href="#理解MD5算法流程" class="headerlink" title="理解MD5算法流程"></a>理解MD5算法流程</h3><p>了解了Merkle–Damgård算法的流程，下面详细了解一下MD5算法的流程<br>MD5算法包括四大步骤：</p><pre><code>1、Append Padding Bits(填充bits)2、Append Length(填充长度)3、Initialize MD Buffer(初始化向量)4、Process Message in 16-Word Blocks(复杂的函数运算)</code></pre><p>我们主要了解前三步即可，主要流程如下：</p><ol><li>根据消息的长度确定填充的字节数，即填充后消息长度 mod 512bit = 448bit。举个例子：一个消息是”message”，则这个消息是56bit，所以需要填充392bit。</li><li>最小填充1bit最多填充512bit，即使消息长度 mod 512 = 448bit。也就是说，不管消息长度是多少，都必须进行填充。</li><li>填充信息的第一个字节是0x80，剩余数据用0x00填充。</li><li>我们关键利用的是MD5的填充，对加密的字符串进行填充(比特第一位为1其余比特为0)，使之(二进制)补到448模512同余，即长度为512的倍数减64，最后的64位在补充为原来字符串的长度，这样刚好补满512位的倍数，如果当前明文正好是512bit倍数则再加上一个512bit的一组。<br>5.MD5不管怎么加密，每一块加密得到的密文作为下一次加密的初始向量IV，这一点很关键！！！</li></ol><p>然后，我们看一下填充长度的流程：</p><pre><code>1、填充长度的大小是64bit2、长度是小端存储的，也就是说高字节放在高地址中3、如果消息的长度大于2 ^ 64，也就是大于2048PB。那么64bit无法存储消息的长度，则取低64bit。</code></pre><p>如下为一个填充补位的实例：</p><p><img src="https://ws1.sinaimg.cn/large/006Zfwodly1fx4cv50lxjj30ho03zjs2.jpg" alt=""></p><p>最后，初始化向量为固定值：<br>装入标准的幻数（四个整数）：标准的幻数（物理顺序）是（A=(01234567)16，B=(89ABCDEF)16，C=(FEDCBA98)16，D=(76543210)16<br>在MD5中为小端存储：（A=0X67452301，B=0XEFCDAB89，C=0X98BADCFE，D=0X10325476）</p><p>PS：大小端存储：<br>所谓的大端模式（Big-endian），是指数据的高字节，保存在内存的低地址中，而数据的低字节，保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；<br>所谓小端模式（Little-endian）, 是指数据的高字节保存在内存的高地址中,而数据的低字节保存在内在的低地址中,这种存储模式将地址的高低和数据位 权有效结合起来,高地址部分权值高,低地址部分权值低,和我们的逻辑方法一致;</p><p><img src="https://ws1.sinaimg.cn/large/006Zfwodly1fx4d3hc758j30jm0ax0sr.jpg" alt=""></p><p>然后，用初始化向量和补位后的消息进行复杂的函数运算，最终得到消息”message”的MD5值为78e731027d8fd50ed642340b7c9a63b3。</p><h3 id="理解MD5长度扩展攻击"><a href="#理解MD5长度扩展攻击" class="headerlink" title="理解MD5长度扩展攻击"></a>理解MD5长度扩展攻击</h3><p>如果一个消息长度大于512bit，则会对消息按512bit进行切分，最后一个消息块进行填充操作。<br>假设我们知道一个7字节也就是56bit的消息的MD5值是78e731027d8fd50ed642340b7c9a63b3。<br>则MD5算法对其进行运算时，会先补位，由于消息的内容我们不知道，所以补位的结果如下图</p><p><img src="https://ws1.sinaimg.cn/large/006Zfwodly1fx4dbccnxkj30hk03pwex.jpg" alt=""></p><p>然后会和初始向量进行复杂的函数运算，因为MD5值为78e731027d8fd50ed642340b7c9a63b3，故得到的结果为</p><p>A=0x0231e778<br>B=0x0ed58f7d<br>C=0x0b3442d6<br>D=0xb3639a7c</p><p>若向补位后的消息再追加一条消息字符串”admin”，则会对这个字符串进行补位，再利用上一个运算算出的值作为初始向量进行函数运算，最终得到的MD5值为e53a681a30ff99e3f6522270ca7db244。</p><p>这样就完成了在不知道消息的情况下，计算出消息+填充+追加消息的MD5值。<br>例子：<br>传送门：<a href="http://ctf5.shiyanbar.com/web/kzhan.php" target="_blank" rel="noopener">http://ctf5.shiyanbar.com/web/kzhan.php</a><br>题目源码：</p><pre><code>$flag = &quot;XXXXXXXXXXXXXXXXXXXXXXX&quot;;$secret = &quot;XXXXXXXXXXXXXXX&quot;; // This secret is 15 characters long for security!$username = $_POST[&quot;username&quot;];$password = $_POST[&quot;password&quot;];if (!empty($_COOKIE[&quot;getmein&quot;])) {    if (urldecode($username) === &quot;admin&quot; &amp;&amp; urldecode($password) != &quot;admin&quot;) {        if ($COOKIE[&quot;getmein&quot;] === md5($secret . urldecode($username . $password))) {            echo &quot;Congratulations! You are a registered user.\n&quot;;            die (&quot;The flag is &quot;. $flag);        }        else {            die (&quot;Your cookies don&#39;t match up! STOP HACKING THIS SITE.&quot;);        }    }    else {        die (&quot;You are not an admin! LEAVE.&quot;);    }}setcookie(&quot;sample-hash&quot;, md5($secret . urldecode(&quot;admin&quot; . &quot;admin&quot;)), time() + (60 * 60 * 24 * 7));if (empty($_COOKIE[&quot;source&quot;])) {    setcookie(&quot;source&quot;, 0, time() + (60 * 60 * 24 * 7));}else {    if ($_COOKIE[&quot;source&quot;] != 0) {        echo &quot;&quot;; // This source code is outputted here    }}</code></pre><p>1.首先$secret变量我们不知道，但是我们知道它的长度<br>2.从下面setcookie函数我们可以通过sample-hash这个变量拿到md5($secret+”admin”+”admin”)的md5值<br>3.我们登陆成功的条件，username==admin&amp;&amp;password！=admin 并且我们要cookie getmein的值等于md5($secret+username+password)<br>虽然我们不知道$secret是什么，但是我们是否已经知道md5($secret+”admin”+”admin”)的值了？（将其MD5值假设为key）这个时候假设我们主动将$secret+”admin”+”admin”+第一组MD5填充 作为第一组明文，第二组明文自己设定的某值，同时我们利用已经知道的key作为我们构造的明文最后一块加密的初始向量IV，那么加密出来的结果应该和$secret+”admin”+”admin”+第一组MD5填充+第二块铭文的MD5值一样的</p><p>xxxxxxxxxxxxxxxadminadmin+’\x80’+’\x00’<em>30+’\xc8’+’\x00’</em>7</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MD5算法攻击方式总结&quot;&gt;&lt;a href=&quot;#MD5算法攻击方式总结&quot; class=&quot;headerlink&quot; title=&quot;MD5算法攻击方式总结&quot;&gt;&lt;/a&gt;MD5算法攻击方式总结&lt;/h1&gt;&lt;h2 id=&quot;0x01前言&quot;&gt;&lt;a href=&quot;#0x01前言&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一道密码题目的总结与感想</title>
    <link href="http://yoursite.com/2018/10/30/%E4%B8%80%E9%81%93%E5%AF%86%E7%A0%81%E9%A2%98%E7%9B%AE%E7%9A%84%E6%80%BB%E7%BB%93%E4%B8%8E%E6%84%9F%E6%83%B3/"/>
    <id>http://yoursite.com/2018/10/30/一道密码题目的总结与感想/</id>
    <published>2018-10-30T07:02:43.000Z</published>
    <updated>2018-10-30T07:10:36.000Z</updated>
    
    <content type="html"><![CDATA[<p><font color="red"><center>作者：ScapeGoat44</center></font></p><h2 id="0x01前言"><a href="#0x01前言" class="headerlink" title="0x01前言"></a>0x01前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;开业大吉，由于更换系统时不当操作导致以前的所有博客全部丢失，心痛ing。。。这是重建博客后的第一篇文章，emmm希望以后越来越好吧！。。<br><a id="more"></a></p><p>&nbsp;&nbsp;&nbsp;&nbsp;由于最近本人遇到了大量的异或加密题目，所以借助一道护网杯的解密题目对此知识点进行分析，关于异或，我们平时理解就是两个值如果相同则异或结果为1，如果两个值不相同，则异或结果为0。不过在此的异或则是把两个字符的ASCII码的二进制表示方式的每一位都进行异或然后得到一个新的二进制数，再把此二进制数还原为字符，在此再说一个重要的tip：0和任何单位异或得到的还是该单位，两个相同的单位异或得到的是0（这个很重要，很多异或题目都需要这样的方法解答）举个小例子：</p><pre><code>字符    对应的二进制表达 a        0110 0001 &lt;        0011 1100</code></pre><p>两者进行异或得到的即为：</p><pre><code> ]        0101 1101</code></pre><p>借助代码验证一下我们的测试：</p><p><img src="https://i.imgur.com/338ozFF.png" alt=""></p><p>运行得到结果：</p><p><img src="https://i.imgur.com/8aahmP6.png" alt=""></p><p>&nbsp;&nbsp;&nbsp;&nbsp;还有一个tip就是异或是循环可逆的，就是A和B异或的到C，然后C和B异或得到的就是A，A和C异或得到的就是B。我们直接改一下刚才的代码测试一下：</p><p><img src="https://i.imgur.com/FAK0MDw.png" alt=""></p><p>运行得到结果：</p><p><img src="https://i.imgur.com/XXH4nfo.png" alt=""></p><h2 id="0x02题目分析"><a href="#0x02题目分析" class="headerlink" title="0x02题目分析"></a>0x02题目分析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;进行完基础知识的分析，我们来分析一道这样的密码题目，这道题目是护网杯上的一道Crypto题目，当时我和刘文博、杨瑞龙三个弟弟花了好长时间也没有做出来，好尴尬！。。赛后才发现我们三个陷入了一个误区，今天就重新分析一下这道题目。<br>题目：<br>fez.py fez.log文件<br>fez.py：</p><pre><code>import osdef xor(a,b):    assert len(a)==len(b)    c=&quot;&quot;    for i in range(len(a)):        c+=chr(ord(a[i])^ord(b[i]))    return cdef f(x,k):    return xor(xor(x,k),7)def round(M,K):    L=M[0:27]    R=M[27:54]    new_l=R    new_r=xor(xor(R,L),K)    return new_l+new_rdef fez(m,K):    for i in K:        m=round(m,i)    return mK=[]for i in range(7):    K.append(os.urandom(27))m=open(&quot;flag&quot;,&quot;rb&quot;).read()assert len(m)&lt;54m+=os.urandom(54-len(m))test=os.urandom(54)print (test.encode(&quot;hex&quot;))print (fez(test,K).encode(&quot;hex&quot;))print (fez(m,K).encode(&quot;hex&quot;))</code></pre><p>fez.log：</p><pre><code>c8b84d08e5a8e60a49578f387fff5a90e9e7c181734bf05be4f5403c9ea24a0b8741a329991637e11fa69019cd3b01d7c95b65f5abd55c3660c27cb9b3785a5ce06022e88bc831017e882d39475ea85d919ad9e5ac498f86c553216cab1f8f7468353d46ba8971efa9ca8c81519ab6fc0e435da00516b844f8fe664bfe9445992f478dc650701739a11ffda5bbeb643159d7e8cd03a2104c798a1ca734b905ee6c76</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;这段python代码大多数人都可以看懂，所以我就简单的分析一下<br>&nbsp;&nbsp;&nbsp;&nbsp;首先看第一个函数xor，该函数接收两个参数，判断这两个参数的长度是否相等，如果相等就对两个参数进行逐位异或，异或后的值为c。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;第二个函数，接收两个参数，对这两个参数调用第一个函数xor进行异或，然后得到的结果与7进行异或，然后返回一个值，不过在这道题中，该函数并未使用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;第三个函数，该函数是本题目的核心，首先接收两个参数M和K，然后将M分为两部分（通过后面的代码我们可以知道在此就是将M对半分），然后将M的后半部分当做返回值的前半部分，将M的前后异或再与K异或得到返回值的后半部分。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;第四个函数其实就是循环调用第三个函数进行加密。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;然后下面通过os模块得到了7个完全随机的长度为27的K值，其实就是我们熟知的密钥。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;test是一个长度为54的随机字符串，然后观察两个文件很明显的就得出fez.log中的三行字符串分别是test的值（注意三行字符串都经过了hex编码）、test与K进行加密的结果、m（也就是flag）与K加密的结果。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;当时我们三个人一直都在想着怎么通过fez.log文件把flag逆运算出来，但是我们搞了很长时间。。终于放弃了！在赛后我们才发现这道题目其实如果真正理解了就会发现它特别简单，其实就是模拟一下正向加密过程，你就会发现想要的答案。</p><p>现在我们首先正向模拟一下test和K的加密过程：</p><pre><code>我们假设test的左半部分为L，右半部分为RK中有七个密钥，我们假设为K1到K7第一次循环：R+R^L^K1第二次循环：R^L^K1+R^R^L^K1^K2         = R^L^K1+L^K1^K2第三次循环：L^K1^K2+R^K^K1^L^K1^K2^K3         = L^K1^K2+R^K2^K3第四次循环：R^K2^K3+L^K1^K2^R^K2^K3^K4         = R^K2^K3+L^K1^K3^K4第五次循环：L^K1^K3^K4+R^K2^K3^L^K1^K3^K4^k5         = L^K1^R^K3^K4+K2^L^K1^K4^K5第六次循环：K2^L^K1^K4^K5+L^K1^R^K3^K4^K2^L^K1^K4^K5^K6         = K2^L^K1^K4^K5+R^K3^K2^K5^K6第七次循环：R^K3^K2^K5^K6+K2^L^K1^K4^K5^R^K3^K2^K5^K6^K7         = R^K3^K2^K5^K6+L^K1^K4^R^K3^K6^K7</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;通过模拟正向加密过程我们发现经过加密函数我们得到的结果只跟初始明文message的前后半段和七个密钥有关，所以m和K进行加密的结果和test和K加密的结果出了R和L不相同其他任何都是相同的！通过这里我们就可以得到我们想要的m。</p><h2 id="0x03解密"><a href="#0x03解密" class="headerlink" title="0x03解密"></a>0x03解密</h2><p>解密脚本：</p><pre><code>import osdef xor(a,b):    assert len(a) == len(b)    c = &#39;&#39;    for i in range(len(a)):        c += chr(ord(a[i]) ^ ord(b[i]))    return ctest = &#39;50543fc0bca1bb4f21300f0074990f846a8009febded0b2198324c1b31d2e2563c908dcabbc461f194e70527e03a807e9a478f9a56f7&#39;test = test.decode(&#39;hex&#39;)test_k = &#39;66bbd551d9847c1a10755987b43f8b214ee9c6ec2949eef01321b0bc42cffce6bdbd604924e5cbd99b7c56cf461561186921087fa1e9&#39;test_k = test_k.decode(&#39;hex&#39;)m_k = &#39;44fc6f82bdd0dff9aca3e0e82cbb9d6683516524c245494b89c272a83d2b88452ec0bfa0a73ffb42e304fe3748896111b9bdf4171903&#39;m_k = m_k.decode(&#39;hex&#39;)l = test[0:27]r = test[27:54]l1 = test_k[0:27]r1 = test_k[27:54]l2 = m_k[0:27]r2 = m_k[27:54]c = xor(xor(l,r),r1)Lr = xor(c,r2)d = xor(r,l1)R = xor(d,l2)L = xor(Lr,R)m = L+R  print m</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;解密代码前半段都没什么说的，主要对后半段进行说明，通过模拟正向加密过程，我们得到最终的密文为R^K3^K2^K5^K6+L^K1^K4^R^K3^K6^K7，其中L、R为明文的左右部分，c = xor(xor(l,r),r1)，仔细看这行代码其实代表的是L^R^L^K1^K4^R^K3^K6^K7，我们发现其中的L和R都被消掉了，所以我们得到了K1^K4^K3^K6^K7的值，Lr = xor(c,r2)，这行代码代表的就是K1^K4^K3^K6^K7^L^K1^K4^R^K3^K6^K7（注意其中的L和R为m的L和R），相同单位异或为零，零与其它异或为它本身，所以我们就得到了m的左右部分异或的结果R^L，d = xor(r,l1)，这行代码代表的是R^R^K3^K2^K5^K6,R被消除，所以我们就得到了K3^K2^K5^K6的值，R = xor(d,l2)代表的就是K3^K2^K5^K6^R^K3^K2^K5^K6（其中R为m的R），所以我们就得到了m的右半部分R，结合刚刚得到的L^R我们就可以通过L^R^R得到m的左半部分L，至此我们就得到了我们想要的明文m！</p><p>&nbsp;&nbsp;&nbsp;&nbsp;关于异或解密我们主要用到的知识点就是1、异或是互逆的；2、0和任何单位异或得到的还是该单位，两个相同的单位异或得到的是0！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font color=&quot;red&quot;&gt;&lt;center&gt;作者：ScapeGoat44&lt;/center&gt;&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x01前言&quot;&gt;&lt;a href=&quot;#0x01前言&quot; class=&quot;headerlink&quot; title=&quot;0x01前言&quot;&gt;&lt;/a&gt;0x01前言&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;开业大吉，由于更换系统时不当操作导致以前的所有博客全部丢失，心痛ing。。。这是重建博客后的第一篇文章，emmm希望以后越来越好吧！。。&lt;br&gt;
    
    </summary>
    
    
      <category term="CTF" scheme="http://yoursite.com/tags/CTF/"/>
    
  </entry>
  
</feed>
