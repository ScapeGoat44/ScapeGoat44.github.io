<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ScapeGoat44</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-30T07:10:36.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一道密码题目的总结与感想</title>
    <link href="http://yoursite.com/2018/10/30/%E4%B8%80%E9%81%93%E5%AF%86%E7%A0%81%E9%A2%98%E7%9B%AE%E7%9A%84%E6%80%BB%E7%BB%93%E4%B8%8E%E6%84%9F%E6%83%B3/"/>
    <id>http://yoursite.com/2018/10/30/一道密码题目的总结与感想/</id>
    <published>2018-10-30T07:02:43.000Z</published>
    <updated>2018-10-30T07:10:36.000Z</updated>
    
    <content type="html"><![CDATA[<p><font color="red"><center>作者：ScapeGoat44</center></font></p><h2 id="0x01前言"><a href="#0x01前言" class="headerlink" title="0x01前言"></a>0x01前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;开业大吉，由于更换系统时不当操作导致以前的所有博客全部丢失，心痛ing。。。这是重建博客后的第一篇文章，emmm希望以后越来越好吧！。。<br><a id="more"></a></p><p>&nbsp;&nbsp;&nbsp;&nbsp;由于最近本人遇到了大量的异或加密题目，所以借助一道护网杯的解密题目对此知识点进行分析，关于异或，我们平时理解就是两个值如果相同则异或结果为1，如果两个值不相同，则异或结果为0。不过在此的异或则是把两个字符的ASCII码的二进制表示方式的每一位都进行异或然后得到一个新的二进制数，再把此二进制数还原为字符，在此再说一个重要的tip：0和任何单位异或得到的还是该单位，两个相同的单位异或得到的是0（这个很重要，很多异或题目都需要这样的方法解答）举个小例子：</p><pre><code>字符    对应的二进制表达 a        0110 0001 &lt;        0011 1100</code></pre><p>两者进行异或得到的即为：</p><pre><code>]        0101 1101</code></pre><p>借助代码验证一下我们的测试：</p><p><img src="https://i.imgur.com/338ozFF.png" alt=""></p><p>运行得到结果：</p><p><img src="https://i.imgur.com/8aahmP6.png" alt=""></p><p>&nbsp;&nbsp;&nbsp;&nbsp;还有一个tip就是异或是循环可逆的，就是A和B异或的到C，然后C和B异或得到的就是A，A和C异或得到的就是B。我们直接改一下刚才的代码测试一下：</p><p><img src="https://i.imgur.com/FAK0MDw.png" alt=""></p><p>运行得到结果：</p><p><img src="https://i.imgur.com/XXH4nfo.png" alt=""></p><h2 id="0x02题目分析"><a href="#0x02题目分析" class="headerlink" title="0x02题目分析"></a>0x02题目分析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;进行完基础知识的分析，我们来分析一道这样的密码题目，这道题目是护网杯上的一道Crypto题目，当时我和刘文博、杨瑞龙三个弟弟花了好长时间也没有做出来，好尴尬！。。赛后才发现我们三个陷入了一个误区，今天就重新分析一下这道题目。<br>题目：<br>fez.py fez.log文件<br>fez.py：</p><pre><code>import osdef xor(a,b):    assert len(a)==len(b)    c=&quot;&quot;    for i in range(len(a)):        c+=chr(ord(a[i])^ord(b[i]))    return cdef f(x,k):    return xor(xor(x,k),7)def round(M,K):    L=M[0:27]    R=M[27:54]    new_l=R    new_r=xor(xor(R,L),K)    return new_l+new_rdef fez(m,K):    for i in K:        m=round(m,i)    return mK=[]for i in range(7):    K.append(os.urandom(27))m=open(&quot;flag&quot;,&quot;rb&quot;).read()assert len(m)&lt;54m+=os.urandom(54-len(m))test=os.urandom(54)print (test.encode(&quot;hex&quot;))print (fez(test,K).encode(&quot;hex&quot;))print (fez(m,K).encode(&quot;hex&quot;))</code></pre><p>fez.log：</p><pre><code>c8b84d08e5a8e60a49578f387fff5a90e9e7c181734bf05be4f5403c9ea24a0b8741a329991637e11fa69019cd3b01d7c95b65f5abd55c3660c27cb9b3785a5ce06022e88bc831017e882d39475ea85d919ad9e5ac498f86c553216cab1f8f7468353d46ba8971efa9ca8c81519ab6fc0e435da00516b844f8fe664bfe9445992f478dc650701739a11ffda5bbeb643159d7e8cd03a2104c798a1ca734b905ee6c76</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;这段python代码大多数人都可以看懂，所以我就简单的分析一下<br>&nbsp;&nbsp;&nbsp;&nbsp;首先看第一个函数xor，该函数接收两个参数，判断这两个参数的长度是否相等，如果相等就对两个参数进行逐位异或，异或后的值为c。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;第二个函数，接收两个参数，对这两个参数调用第一个函数xor进行异或，然后得到的结果与7进行异或，然后返回一个值，不过在这道题中，该函数并未使用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;第三个函数，该函数是本题目的核心，首先接收两个参数M和K，然后将M分为两部分（通过后面的代码我们可以知道在此就是将M对半分），然后将M的后半部分当做返回值的前半部分，将M的前后异或再与K异或得到返回值的后半部分。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;第四个函数其实就是循环调用第三个函数进行加密。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;然后下面通过os模块得到了7个完全随机的长度为27的K值，其实就是我们熟知的密钥。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;test是一个长度为54的随机字符串，然后观察两个文件很明显的就得出fez.log中的三行字符串分别是test的值（注意三行字符串都经过了hex编码）、test与K进行加密的结果、m（也就是flag）与K加密的结果。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;当时我们三个人一直都在想着怎么通过fez.log文件把flag逆运算出来，但是我们搞了很长时间。。终于放弃了！在赛后我们才发现这道题目其实如果真正理解了就会发现它特别简单，其实就是模拟一下正向加密过程，你就会发现想要的答案。</p><p>现在我们首先正向模拟一下test和K的加密过程：</p><pre><code>我们假设test的左半部分为L，右半部分为RK中有七个密钥，我们假设为K1到K7第一次循环：R+R^L^K1第二次循环：R^L^K1+R^R^L^K1^K2         = R^L^K1+L^K1^K2第三次循环：L^K1^K2+R^K^K1^L^K1^K2^K3         = L^K1^K2+R^K2^K3第四次循环：R^K2^K3+L^K1^K2^R^K2^K3^K4         = R^K2^K3+L^K1^K3^K4第五次循环：L^K1^K3^K4+R^K2^K3^L^K1^K3^K4^k5         = L^K1^R^K3^K4+K2^L^K1^K4^K5第六次循环：K2^L^K1^K4^K5+L^K1^R^K3^K4^K2^L^K1^K4^K5^K6         = K2^L^K1^K4^K5+R^K3^K2^K5^K6第七次循环：R^K3^K2^K5^K6+K2^L^K1^K4^K5^R^K3^K2^K5^K6^K7         = R^K3^K2^K5^K6+L^K1^K4^R^K3^K6^K7</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;通过模拟正向加密过程我们发现经过加密函数我们得到的结果只跟初始明文message的前后半段和七个密钥有关，所以m和K进行加密的结果和test和K加密的结果出了R和L不相同其他任何都是相同的！通过这里我们就可以得到我们想要的m。</p><h2 id="0x03解密"><a href="#0x03解密" class="headerlink" title="0x03解密"></a>0x03解密</h2><p>解密脚本：</p><pre><code>import osdef xor(a,b):    assert len(a) == len(b)    c = &apos;&apos;    for i in range(len(a)):        c += chr(ord(a[i]) ^ ord(b[i]))    return ctest = &apos;50543fc0bca1bb4f21300f0074990f846a8009febded0b2198324c1b31d2e2563c908dcabbc461f194e70527e03a807e9a478f9a56f7&apos;test = test.decode(&apos;hex&apos;)test_k = &apos;66bbd551d9847c1a10755987b43f8b214ee9c6ec2949eef01321b0bc42cffce6bdbd604924e5cbd99b7c56cf461561186921087fa1e9&apos;test_k = test_k.decode(&apos;hex&apos;)m_k = &apos;44fc6f82bdd0dff9aca3e0e82cbb9d6683516524c245494b89c272a83d2b88452ec0bfa0a73ffb42e304fe3748896111b9bdf4171903&apos;m_k = m_k.decode(&apos;hex&apos;)l = test[0:27]r = test[27:54]l1 = test_k[0:27]r1 = test_k[27:54]l2 = m_k[0:27]r2 = m_k[27:54]c = xor(xor(l,r),r1)Lr = xor(c,r2)d = xor(r,l1)R = xor(d,l2)L = xor(Lr,R)m = L+R  print m</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;解密代码前半段都没什么说的，主要对后半段进行说明，通过模拟正向加密过程，我们得到最终的密文为R^K3^K2^K5^K6+L^K1^K4^R^K3^K6^K7，其中L、R为明文的左右部分，c = xor(xor(l,r),r1)，仔细看这行代码其实代表的是L^R^L^K1^K4^R^K3^K6^K7，我们发现其中的L和R都被消掉了，所以我们得到了K1^K4^K3^K6^K7的值，Lr = xor(c,r2)，这行代码代表的就是K1^K4^K3^K6^K7^L^K1^K4^R^K3^K6^K7（注意其中的L和R为m的L和R），相同单位异或为零，零与其它异或为它本身，所以我们就得到了m的左右部分异或的结果R^L，d = xor(r,l1)，这行代码代表的是R^R^K3^K2^K5^K6,R被消除，所以我们就得到了K3^K2^K5^K6的值，R = xor(d,l2)代表的就是K3^K2^K5^K6^R^K3^K2^K5^K6（其中R为m的R），所以我们就得到了m的右半部分R，结合刚刚得到的L^R我们就可以通过L^R^R得到m的左半部分L，至此我们就得到了我们想要的明文m！</p><p>&nbsp;&nbsp;&nbsp;&nbsp;关于异或解密我们主要用到的知识点就是1、异或是互逆的；2、0和任何单位异或得到的还是该单位，两个相同的单位异或得到的是0！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font color=&quot;red&quot;&gt;&lt;center&gt;作者：ScapeGoat44&lt;/center&gt;&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x01前言&quot;&gt;&lt;a href=&quot;#0x01前言&quot; class=&quot;headerlink&quot; title=&quot;0x01前言&quot;&gt;&lt;/a&gt;0x01前言&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;开业大吉，由于更换系统时不当操作导致以前的所有博客全部丢失，心痛ing。。。这是重建博客后的第一篇文章，emmm希望以后越来越好吧！。。&lt;br&gt;
    
    </summary>
    
    
      <category term="CTF" scheme="http://yoursite.com/tags/CTF/"/>
    
  </entry>
  
</feed>
